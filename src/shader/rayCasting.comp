/***********************************************************************
 * @file	rayCasting.comp
 * @author	jjyou
 * @date	2024-4-10
 * @brief	This file implements ray casting algorithm.
***********************************************************************/

#version 450

layout (local_size_x = 32, local_size_y = 32) in;

/** @brief	Input TSDF volume.
  * 
  *			A storage buffer containing all information about the TSDF volume.
  */
layout(set = 0, binding = 0) readonly buffer TSDFVolume {
	uvec3 resolution;
	float size;
	vec3 corner;
	float truncationDistance;
	vec2 data[];
} tsdfVolume;

/** @brief	Ray casting parameters.
  */
layout(set = 1, binding = 0) uniform RayCastingParameters {
	mat4 invProjection;
	mat4 invView;
	float minDepth;
	float maxDepth;
	float invalidDepth;
	float marchingStep;
} rayCastingParameters;

/** @brief	Output surface textures.
  * 
  *			Three textures for color, depth, and normal respectively.
  *			Currently, the color map is always constant. Extensions may be
  *			made in the future to support color fusion.
  *			The depth map is true-depth. It is not in the clipped space of
  *			graphics rendering.
  */
layout (set = 2, binding = 0, rgba8) uniform image2D surfaceColorTexture;
layout (set = 2, binding = 1, r32f) uniform image2D surfaceDepthTexture;
layout (set = 2, binding = 2, rgba32f) uniform image2D surfaceNormalTexture;

/** @brief	Helper function that compute the min intersection distance.
  */
float getMinT(vec3 rayOrigin, vec3 rayDir, vec3 minCorner, vec3 maxCorner) {
	float xMin = ((rayDir.x > 0.0 ? minCorner.x : maxCorner.x) - rayOrigin.x) / rayDir.x;
	float yMin = ((rayDir.y > 0.0 ? minCorner.y : maxCorner.y) - rayOrigin.y) / rayDir.y;
	float zMin = ((rayDir.z > 0.0 ? minCorner.z : maxCorner.z) - rayOrigin.z) / rayDir.z;
	return max(max(xMin, yMin), zMin);
}

/** @brief	Helper function that compute the max intersection distance.
  */
float getMaxT(vec3 rayOrigin, vec3 rayDir, vec3 minCorner, vec3 maxCorner) {
	float xMax = ((rayDir.x > 0.0 ? maxCorner.x : minCorner.x) - rayOrigin.x) / rayDir.x;
	float yMax = ((rayDir.y > 0.0 ? maxCorner.y : minCorner.y) - rayOrigin.y) / rayDir.y;
	float zMax = ((rayDir.z > 0.0 ? maxCorner.z : minCorner.z) - rayOrigin.z) / rayDir.z;
	return min(min(xMax, yMax), zMax);
}

/** @brief	Helper function to read a voxel.
  * @note	It's the caller's reponsibility to make sure `index` is within valid range.
  */
vec2 readVoxel(uvec3 index) {
	return tsdfVolume.data[(index.x *  tsdfVolume.resolution.y + index.y) * tsdfVolume.resolution.z + index.z];
}

/** @brief	Compute the coefficients of trilinear interpolation.
  * @sa		https://en.wikipedia.org/wiki/Trilinear_interpolation#Alternative_algorithm
  *	@param	normalizedPos	Normalized position in [0, 1]^3
  *	@param	tsdf			The 8 nearest voxels' TSDF value
  *	@param	coeff			Output coefficients.
  *
  *			Since we normalized the position to [0, 1]^3, the formula can be simplified
  *			a lot. (Plugging x0=y0=z0=0 and x1=y1=z1=1 into the original formula.)
  */
void getCoefficients(in vec3 normalizedPos, in float tsdf[2][2][2], out float coeff[8]) {
	coeff[0] = tsdf[0][0][0];
	coeff[1] = -tsdf[0][0][0] + tsdf[1][0][0];
	coeff[2] = -tsdf[0][0][0] + tsdf[0][1][0];
	coeff[3] = -tsdf[0][0][0] + tsdf[0][0][1];
	coeff[4] = tsdf[0][0][0] - tsdf[0][1][0] - tsdf[1][0][0] + tsdf[1][1][0];
	coeff[5] = tsdf[0][0][0] - tsdf[0][0][1] - tsdf[1][0][0] + tsdf[1][0][1];
	coeff[6] = tsdf[0][0][0] - tsdf[0][0][1] - tsdf[0][1][0] + tsdf[0][1][1];
	coeff[7] = -tsdf[0][0][0] + tsdf[0][0][1] + tsdf[0][1][0] - tsdf[0][1][1] + tsdf[1][0][0] - tsdf[1][0][1] - tsdf[1][1][0] + tsdf[1][1][1];
}

/** @brief	Helper function to interpolate the TSDF value.
  * @note	It's the caller's reponsibility to make sure `pos` is within valid range.
  * @param	pos		The position in world space.
  * @param	valid	Indicate whether the 8 corners contain zero-weighted voxels.
  * @return			The interpolated TSDF value.
  */
float interpolateTSDF(in vec3 pos, out bool valid) {
	valid = true;
	uvec3 baseIndex = uvec3((pos - tsdfVolume.corner) / tsdfVolume.size);
	for (uint i = 0; i < 3; ++i)
		baseIndex[i] = min(max(baseIndex[i], 0), tsdfVolume.resolution[i] - 1);
	// Normalize pos to [0, 1]^3
	vec3 normalizedPos = (pos - tsdfVolume.corner) / tsdfVolume.size - vec3(baseIndex);
	// Read 8 nearest voxels.
	float tsdf[2][2][2];
	for (uint dx = 0; dx < 2; ++dx)
		for (uint dy = 0; dy < 2; ++dy)
			for (uint dz = 0; dz < 2; ++dz) {
				vec2 voxel = readVoxel(baseIndex + uvec3(dx, dy, dz));
				if (voxel.y == 0.0) valid = false;
				tsdf[dx][dy][dz] = voxel.x;
			}
	// Interpolate
	float coeff[8];
	getCoefficients(normalizedPos, tsdf, coeff);
	float interpolated = \
		coeff[0] +
		coeff[1] * normalizedPos.x + \
		coeff[2] * normalizedPos.y + \
		coeff[3] * normalizedPos.z + \
		coeff[4] * normalizedPos.x * normalizedPos.y + \
		coeff[5] * normalizedPos.x * normalizedPos.z + \
		coeff[6] * normalizedPos.y * normalizedPos.z + \
		coeff[7] * normalizedPos.x * normalizedPos.y * normalizedPos.z;
	return interpolated;
}

/** @brief	Helper function to compute the normal at a point on the zero-surface.
  * @note	It's the caller's reponsibility to make sure `pos` is within valid range.
  * @param	pos		The position in world space. It should be on the zero-surface.
  * @return			The interpolated TSDF value.
  */
vec3 computeNormal(vec3 pos) {
	uvec3 baseIndex = uvec3((pos - tsdfVolume.corner) / tsdfVolume.size);
	for (uint i = 0; i < 3; ++i)
		baseIndex[i] = min(max(baseIndex[i], 0), tsdfVolume.resolution[i] - 1);
	// Normalize pos to [0, 1]^3
	vec3 normalizedPos = (pos - tsdfVolume.corner) / tsdfVolume.size - vec3(baseIndex);
	// Read 8 nearest voxels.
	float tsdf[2][2][2];
	for (uint dx = 0; dx < 2; ++dx)
		for (uint dy = 0; dy < 2; ++dy)
			for (uint dz = 0; dz < 2; ++dz) {
				vec2 voxel = readVoxel(baseIndex + uvec3(dx, dy, dz));
				tsdf[dx][dy][dz] = voxel.x;
			}
	// Get the coefficients of trilinear interpolation.
	float coeff[8];
	getCoefficients(normalizedPos, tsdf, coeff);
	// The normal should be the gradient of the interpolated TSDF.
	vec3 normal = normalize(vec3(
		coeff[1] + coeff[4] * normalizedPos.y + coeff[5] * normalizedPos.z + coeff[7] * normalizedPos.y * normalizedPos.z,
		coeff[2] + coeff[4] * normalizedPos.x + coeff[6] * normalizedPos.z + coeff[7] * normalizedPos.x * normalizedPos.z,
		coeff[3] + coeff[5] * normalizedPos.x + coeff[6] * normalizedPos.y + coeff[7] * normalizedPos.x * normalizedPos.y
	));
	return normal;
}

/** @brief	Function that actually does ray casting.
  */
bool rayCasting(
	in vec3 rayOrigin, in vec3 rayDir, in float scaleFactor,
	out vec4 outColor, out float outDepth, out vec3 outNormal
) {
	// Compute t range
	rayDir.x = (rayDir.x == 0.0) ? 1e-5 : rayDir.x;
	rayDir.y = (rayDir.y == 0.0) ? 1e-5 : rayDir.y;
	rayDir.z = (rayDir.z == 0.0) ? 1e-5 : rayDir.z;
	vec3 minCorner = tsdfVolume.corner;
	vec3 maxCorner = tsdfVolume.corner + vec3(tsdfVolume.resolution - 1) * tsdfVolume.size;
	float minT = getMinT(rayOrigin, rayDir, minCorner, maxCorner);
	minT = max(minT, rayCastingParameters.minDepth * scaleFactor);
	float maxT = getMaxT(rayOrigin, rayDir, minCorner, maxCorner);
	maxT = min(maxT, rayCastingParameters.maxDepth * scaleFactor);
	if (minT >= maxT)
		return false;
	// Start ray casting
	float currT = minT + 1e-5;
	float lastT = -1.0;
	float currTSDF = -1.0;
	float lastTSDF = -1.0;
	while (currT < maxT) {
		bool valid = true;
		currTSDF = interpolateTSDF(rayOrigin + rayDir * currT, valid);
		if (!valid) {
			// One or more surrounding voxels are zero-weighted. Continue marching.
			lastT = currT;
			currT += tsdfVolume.truncationDistance * 0.95;
			lastTSDF = -1.0;
			continue;
		}
		else if (currTSDF > 1e-5) {
			// Still outside of the zero-surface. Continue marching.
			lastT = currT;
			currT += max(rayCastingParameters.marchingStep, tsdfVolume.truncationDistance * currTSDF * 0.95);
			lastTSDF = currTSDF;
			continue;
		}
		else if (currTSDF < -1e-5) {
			// Inside of the zero-surface.
			if (lastTSDF > 0.0) {
				// Find zero-surface.
				float t = lastT + (currT - lastT) * lastTSDF / (lastTSDF - currTSDF);
				outColor = vec4(0.6, 0.6, 0.6, 1.0);
				outDepth = t / scaleFactor;
				outNormal = computeNormal(rayOrigin + t * rayDir);
				return true;
			}
			else {
				// Failed.
				return false;
			}
		}
		else {
			// Find zero-surface.
			float t = currT;
			outColor = vec4(0.6, 0.6, 0.6, 1.0);
			outDepth = t / scaleFactor;
			outNormal = computeNormal(rayOrigin + t * rayDir);
			return true;
		}
	}
	return false;
}

void main(){

	ivec2 outputPixelPos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	ivec2 outputSize = imageSize(surfaceColorTexture);
	if (outputPixelPos.x >= outputSize.x || outputPixelPos.y >= outputSize.y)
		return;

	// Compute ray direction and origin in the world space
	vec3 rayOrigin = rayCastingParameters.invView[3].xyz;
	vec3 rayDir = vec3(float(outputPixelPos.x), float(outputPixelPos.y), 1.0);
	rayDir = mat3(rayCastingParameters.invProjection) * rayDir;
	float scaleFactor = length(rayDir);
	rayDir = normalize(mat3(rayCastingParameters.invView) * rayDir);

	// Ray casting
	vec4 outColor;
	float outDepth;
	vec3 outNormal;
	if (!rayCasting(rayOrigin, rayDir, scaleFactor, outColor, outDepth, outNormal)) {
		outColor = vec4(0.0, 0.0, 0.0, 0.0);
		outDepth = rayCastingParameters.invalidDepth;
		outNormal = vec3(0.0, 0.0, 0.0);
	}

	// Store
	imageStore(surfaceColorTexture, outputPixelPos, outColor);
	imageStore(surfaceDepthTexture, outputPixelPos, vec4(outDepth));
	imageStore(surfaceNormalTexture, outputPixelPos, vec4(outNormal, 1.0));
}