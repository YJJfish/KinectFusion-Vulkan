/***********************************************************************
 * @file	rayCasting.comp
 * @author	jjyou
 * @date	2024-4-10
 * @brief	This file implements ray casting algorithm.
***********************************************************************/

#version 450

layout (local_size_x = 32, local_size_y = 32) in;

/** @brief	Input TSDF volume.
  * 
  *			A storage buffer containing all information about the TSDF volume.
  */
layout(set = 0, binding = 0) readonly buffer TSDFVolume {
	uvec3 resolution;
	float size;
	vec3 corner;
	float truncationDistance;
	vec2 data[];
} tsdfVolume;

/** @brief	Ray casting parameters.
  */
layout(set = 1, binding = 0) readonly buffer RayCastingParameters {
	mat4 invProjection;
	mat4 invView;
	float minDepth;
	float maxDepth;
	float marchingStep;
	float invalidDepth;
} rayCastingParameters;

/** @brief	Output surface textures.
  * 
  *			Three textures for color, depth, and normal respectively.
  *			Currently, the color map is always constant. Extensions may be
  *			made in the future to support color fusion.
  */
layout (set = 2, binding = 0, rgba8) uniform image2D surfaceColorTexture;
layout (set = 2, binding = 1, r32f) uniform image2D surfaceDepthTexture;
layout (set = 2, binding = 2, rgba32f) uniform image2D surfaceNormalTexture;

/** @brief	Helper function that compute the min intersection distance.
  */
float getMinT(vec3 rayOrigin, vec3 rayDir, vec3 minCorner, vec3 maxCorner) {
	float xMin = ((rayDir.x > 0.0 ? minCorner.x : maxCorner.x) - rayOrigin.x) / rayDir.x;
	float yMin = ((rayDir.y > 0.0 ? minCorner.y : maxCorner.y) - rayOrigin.y) / rayDir.y;
	float zMin = ((rayDir.z > 0.0 ? minCorner.z : maxCorner.z) - rayOrigin.z) / rayDir.z;
	return max(max(xMin, yMin), zMin);
}

/** @brief	Helper function that compute the max intersection distance.
  */
float getMaxT(vec3 rayOrigin, vec3 rayDir, vec3 minCorner, vec3 maxCorner) {
	float xMax = ((rayDir.x > 0.0 ? maxCorner.x : minCorner.x) - rayOrigin.x) / rayDir.x;
	float yMax = ((rayDir.y > 0.0 ? maxCorner.y : minCorner.y) - rayOrigin.y) / rayDir.y;
	float zMax = ((rayDir.z > 0.0 ? maxCorner.z : minCorner.z) - rayOrigin.z) / rayDir.z;
	return min(min(xMax, yMax), zMax);
}

/** @brief	Helper function to read a voxel.
  * @note	It's the caller's reponsibility to make sure `index` is within valid range.
  */
vec2 readVoxel(uvec3 index) {
	return tsdfVolume.data[(index.x *  tsdfVolume.resolution.y + index.y) * tsdfVolume.resolution.z + index.z];
}

/** @brief	Helper function to interpolate the TSDF value.
  * @note	It's the caller's reponsibility to make sure `pos` is within valid range.
  * @param	pos		The position in world space.
  * @param	valid	Indicate whether the 8 corners contain zero-weighted voxels.
  * @return		The interpolated TSDF value.
  */
float interpolateTSDF(in vec3 pos, out bool valid) {
	valid = true;
	uvec3 baseIndex = uvec3((pos - tsdfVolume.corner) / tsdfVolume.size);
	for (uint i = 0; i < 3; ++i)
		baseIndex[i] = min(max(baseIndex[i], 0), tsdfVolume.resolution[i] - 1);
	vec3 normalizedPos = (pos - tsdfVolume.corner) / tsdfVolume.size - vec3(baseIndex);
	// Read 8 nearest voxels.
	float tsdf[2][2][2];
	for (uint dx = 0; dx < 2; ++dx)
		for (uint dy = 0; dy < 2; ++dy)
			for (uint dz = 0; dz < 2; ++dz) {
				vec2 voxel = readVoxel(baseIndex + uvec3(dx, dy, dz));
				if (voxel.y == 0.0) valid = false;
				tsdf[dx][dy][dz] = voxel.x;
			}
	// Interpolate along the x axis.
	float xInterpolated[2][2];
	for (uint dy = 0; dy < 2; ++dy)
		for (uint dz = 0; dz < 2; ++dz) {
			xInterpolated[dy][dz] = tsdf[0][dy][dz] * (1.0 - normalizedPos.x) + tsdf[1][dy][dz] * (normalizedPos.x);
		}
	// Interpolate along the y axis.
	float xyInterpolated[2];
	for (uint dz = 0; dz < 2; ++dz) {
		xyInterpolated[dz] = xInterpolated[0][dz] * (1.0 - normalizedPos.y) + xInterpolated[1][dz] * (normalizedPos.y);
	}
	// Interpolate along the z axis.
	float xyzInterpolated;
	{
		xyzInterpolated = xyInterpolated[0] * (1.0 - normalizedPos.z) + xyInterpolated[1] * (normalizedPos.z);
	}
	return xyzInterpolated;
} 

/** @brief	Function that actually does ray casting.
  */
bool rayCasting(
	in vec3 rayOrigin, in vec3 rayDir, in float scaleFactor,
	out vec4 outColor, out float outDepth, out vec3 outNormal
) {
	// Compute t range
	rayDir.x = (rayDir.x == 0.0) ? 1e-5 : rayDir.x;
	rayDir.y = (rayDir.y == 0.0) ? 1e-5 : rayDir.y;
	rayDir.z = (rayDir.z == 0.0) ? 1e-5 : rayDir.z;
	vec3 minCorner = tsdfVolume.corner;
	vec3 maxCorner = tsdfVolume.corner + vec3(tsdfVolume.resolution - 1) * tsdfVolume.size;
	float minT = getMinT(rayOrigin, rayDir, minCorner, maxCorner);
	minT = max(minT, rayCastingParameters.minDepth * scaleFactor);
	float maxT = getMaxT(rayOrigin, rayDir, minCorner, maxCorner);
	maxT = min(maxT, rayCastingParameters.maxDepth * scaleFactor);
	if (minT >= maxT) return false;
	// Start ray casting
	float currT = minT + 1e-5;
	float lastT = -1.0;
	float currTSDF = -1.0;
	float lastTSDF = -1.0;
	while (currT < maxT) {
		bool valid = true;
		currTSDF = interpolateTSDF(rayOrigin + rayDir * currT, valid);
		if (!valid) {
			// One or more surrounding voxels are zero-weighted. Continue marching.
			lastT = currT;
			currT += rayCastingParameters.marchingStep;
			lastTSDF = -1.0;
			continue;
		}
		else if (currTSDF > 1e-5) {
			// Still outside of the zero-surface. Continue marching.
			lastT = currT;
			currT += rayCastingParameters.marchingStep;
			lastTSDF = currTSDF;
			continue;
		}
		else if (currTSDF < -1e-5) {
			// Inside of the zero-surface.
			if (lastTSDF > 0.0) {
				// Find zero-surface.
				float t = lastT + (currT - lastT) * lastTSDF / (lastTSDF - currTSDF);
				outColor = vec4(0.6, 0.6, 0.6, 1.0);
				outDepth = t / scaleFactor;
				outNormal = rayDir;
				return true;
			}
			else {
				// Failed.
				return false;
			}
		}
		else {
			// Find zero-surface.
			float t = currT;
			outColor = vec4(0.6, 0.6, 0.6, 1.0);
			outDepth = t / scaleFactor;
			outNormal = rayDir;
			return true;
		}
	}
	return false;
}

void main(){

	ivec2 outputPixelPos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	ivec2 outputSize = imageSize(surfaceColorTexture);
	if (outputPixelPos.x >= outputSize.x || outputPixelPos.y >= outputSize.y)
		return;

	// Compute ray direction and origin in the world space
	vec3 rayOrigin = rayCastingParameters.invView[3].xyz;
	vec3 rayDir = vec3(float(outputPixelPos.x) + 0.5, float(outputPixelPos.y) + 0.5, 1.0);
	rayDir = mat3(rayCastingParameters.invProjection) * rayDir;
	float scaleFactor = length(rayDir);
	rayDir = normalize(mat3(rayCastingParameters.invView) * rayDir);

	// Ray casting
	vec4 outColor = vec4(0.0, 0.0, 0.0, 0.0);
	float outDepth = rayCastingParameters.invalidDepth;
	vec3 outNormal = vec3(0.0, 0.0, 0.0);
	rayCasting(rayOrigin, rayDir, scaleFactor, outColor, outDepth, outNormal);

	// Store
	imageStore(surfaceColorTexture, outputPixelPos, outColor);
	imageStore(surfaceDepthTexture, outputPixelPos, vec4(outDepth));
	imageStore(surfaceNormalTexture, outputPixelPos, vec4(outNormal, 1.0));
}