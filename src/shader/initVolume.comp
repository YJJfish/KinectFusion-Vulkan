/***********************************************************************
 * @file	initVolume.comp
 * @author	jjyou
 * @date	2024-4-6
 * @brief	This file implements the compute shader to initialize the
 *			TSDF volume.
***********************************************************************/

#version 450

layout (local_size_x = 32, local_size_y = 32) in;

/** @brief	Input TSDF volume.
  * 
  * A storage buffer containing all information about the TSDF volume.
  */
layout(set = 0, binding = 0) buffer TSDFVolume {
	uvec3 resolution;
	float size;
	vec3 corner;
	float truncationDistance;
	ivec2 data[];
} tsdfVolume;

/** @brief	Helper function to pack float TSDF and integer weight into two shorts.
  */
void packVoxel(in float tsdf, in int weight, out int packedVoxel) {
	packedVoxel = (int(tsdf * 32767.0) << 16) | weight;
}

/** @brief	Helper function to unpack two shorts to float TSDF and integer weight.
  */
void unpackVoxel(in int packedVoxel, out float tsdf, out int weight) {
	tsdf = float(packedVoxel >> 16) * (1.0 / 32767.0);
	weight = packedVoxel & 0x0000FFFF;
}

/** @brief	Helper function to pack 4 channel color into an int.
  */
void packColor(in vec4 color, out int packedColor) {
	packedColor = int(packUnorm4x8(color));
}

/** @brief	Helper function to unpack an int to 4 channel color.
  */
void unpackColor(in int packedColor, out vec4 color) {
	color = unpackUnorm4x8(uint(packedColor));
}

void main() {
	if (gl_GlobalInvocationID.x >= tsdfVolume.resolution.x || gl_GlobalInvocationID.y >= tsdfVolume.resolution.y)
		return;
	uint baseVoxelIndex = (gl_GlobalInvocationID.x * tsdfVolume.resolution.y + gl_GlobalInvocationID.y) * tsdfVolume.resolution.z;
	for (uint z = 0; z < tsdfVolume.resolution.z; ++z) {
		ivec2 data;
		packVoxel(0.0, 0, data.x);
		packColor(vec4(0.0, 0.0, 0.0, 1.0), data.y);
		tsdfVolume.data[baseVoxelIndex + z] = data;
	}
	return;
}